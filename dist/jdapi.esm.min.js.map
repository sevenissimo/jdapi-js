{
  "version": 3,
  "sources": ["../src/const.js", "../src/exception.js", "../src/index.js"],
  "sourcesContent": ["/**\n * Constants of the MyJDownloader API.\n * API Documentation: https://my.jdownloader.org/developers\n */\n\n// MyJdownloader exception source\nexport const EXCEPTION_MYJD = \"MYJD\";\nexport const EXCEPTION_DEVICE = \"DEVICE\";\n\n// MyJdownloader exception type\nexport const EXCEPTION_API_COMMAND_NOT_FOUND = \"API_COMMAND_NOT_FOUND\";\nexport const EXCEPTION_API_INTERFACE_NOT_FOUND = \"API_INTERFACE_NOT_FOUND\";\nexport const EXCEPTION_AUTH_FAILED = \"AUTH_FAILED\";\nexport const EXCEPTION_BAD_PARAMETERS = \"BAD_PARAMETERS\";\nexport const EXCEPTION_BAD_REQUEST = \"BAD_REQUEST\";\nexport const EXCEPTION_CHALLENGE_FAILED = \"CHALLENGE_FAILED\";\nexport const EXCEPTION_EMAIL_FORBIDDEN = \"EMAIL_FORBIDDEN\";\nexport const EXCEPTION_EMAIL_INVALID = \"EMAIL_INVALID\";\nexport const EXCEPTION_ERROR_EMAIL_NOT_CONFIRMED = \"ERROR_EMAIL_NOT_CONFIRMED\";\nexport const EXCEPTION_FAILED = \"FAILED\";\nexport const EXCEPTION_FILE_NOT_FOUND = \"FILE_NOT_FOUND\";\nexport const EXCEPTION_INTERNAL_SERVER_ERROR = \"INTERNAL_SERVER_ERROR\";\nexport const EXCEPTION_MAINTENANCE = \"MAINTENANCE\";\nexport const EXCEPTION_METHOD_FORBIDDEN = \"METHOD_FORBIDDEN\";\nexport const EXCEPTION_OFFLINE = \"OFFLINE\";\nexport const EXCEPTION_OUTDATED = \"OUTDATED\";\nexport const EXCEPTION_OVERLOAD = \"OVERLOAD\";\nexport const EXCEPTION_SESSION = \"SESSION\";\nexport const EXCEPTION_STORAGE_ALREADY_EXISTS = \"STORAGE_ALREADY_EXISTS\";\nexport const EXCEPTION_STORAGE_INVALID_KEY = \"STORAGE_INVALID_KEY\";\nexport const EXCEPTION_STORAGE_INVALID_STORAGEID = \"STORAGE_INVALID_STORAGEID\";\nexport const EXCEPTION_STORAGE_KEY_NOT_FOUND = \"STORAGE_KEY_NOT_FOUND\";\nexport const EXCEPTION_STORAGE_LIMIT_REACHED = \"STORAGE_LIMIT_REACHED\";\nexport const EXCEPTION_STORAGE_NOT_FOUND = \"STORAGE_NOT_FOUND\";\nexport const EXCEPTION_TOKEN_INVALID = \"TOKEN_INVALID\";\nexport const EXCEPTION_TOO_MANY_REQUESTS = \"TOO_MANY_REQUESTS\";\nexport const EXCEPTION_UNKNOWN = \"UNKNOWN\";", "/**\n * Exceptions of the MyJDownloader API.\n */\nimport * as C from './const.js';\n\nexport class MYJDException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n\nexport class MYJDConnectionException extends MYJDException {}\nexport class MYJDDeviceNotFoundException extends MYJDException {}\nexport class MYJDDecodeException extends MYJDException {}\n\nexport class MYJDApiException extends MYJDException {\n    constructor(exceptionSource, ...args) {\n        super(...args);\n        this.source = exceptionSource.toUpperCase();\n    }\n\n    static getException(exceptionSource, exceptionType = C.EXCEPTION_UNKNOWN, ...args) {\n        const ExceptionClass = EXCEPTION_CLASSES[exceptionType.toUpperCase()] || MYJDUnknownException;\n        return new ExceptionClass(exceptionSource, ...args);\n    }\n}\n\nexport class MYJDApiCommandNotFoundException extends MYJDApiException {}\nexport class MYJDApiInterfaceNotFoundException extends MYJDApiException {}\nexport class MYJDAuthFailedException extends MYJDApiException {}\nexport class MYJDBadParametersException extends MYJDApiException {}\nexport class MYJDBadRequestException extends MYJDApiException {}\nexport class MYJDChallengeFailedException extends MYJDApiException {}\nexport class MYJDEmailForbiddenException extends MYJDApiException {}\nexport class MYJDEmailInvalidException extends MYJDApiException {}\nexport class MYJDErrorEmailNotConfirmedException extends MYJDApiException {}\nexport class MYJDFailedException extends MYJDApiException {}\nexport class MYJDFileNotFoundException extends MYJDApiException {}\nexport class MYJDInternalServerErrorException extends MYJDApiException {}\nexport class MYJDMaintenanceException extends MYJDApiException {}\nexport class MYJDMethodForbiddenException extends MYJDApiException {}\nexport class MYJDOfflineException extends MYJDApiException {}\nexport class MYJDOutdatedException extends MYJDApiException {}\nexport class MYJDOverloadException extends MYJDApiException {}\nexport class MYJDSessionException extends MYJDApiException {}\nexport class MYJDStorageAlreadyExistsException extends MYJDApiException {}\nexport class MYJDStorageInvalidKeyException extends MYJDApiException {}\nexport class MYJDStorageInvalidStorageIdException extends MYJDApiException {}\nexport class MYJDStorageKeyNotFoundException extends MYJDApiException {}\nexport class MYJDStorageLimitReachedException extends MYJDApiException {}\nexport class MYJDStorageNotFoundException extends MYJDApiException {}\nexport class MYJDTokenInvalidException extends MYJDApiException {}\nexport class MYJDTooManyRequestsException extends MYJDApiException {}\nexport class MYJDUnknownException extends MYJDApiException {}\n\nexport const EXCEPTION_CLASSES = {\n    [C.EXCEPTION_API_COMMAND_NOT_FOUND]: MYJDApiCommandNotFoundException,\n    [C.EXCEPTION_API_INTERFACE_NOT_FOUND]: MYJDApiInterfaceNotFoundException,\n    [C.EXCEPTION_AUTH_FAILED]: MYJDAuthFailedException,\n    [C.EXCEPTION_BAD_PARAMETERS]: MYJDBadParametersException,\n    [C.EXCEPTION_BAD_REQUEST]: MYJDBadRequestException,\n    [C.EXCEPTION_CHALLENGE_FAILED]: MYJDChallengeFailedException,\n    [C.EXCEPTION_EMAIL_FORBIDDEN]: MYJDEmailForbiddenException,\n    [C.EXCEPTION_EMAIL_INVALID]: MYJDEmailInvalidException,\n    [C.EXCEPTION_ERROR_EMAIL_NOT_CONFIRMED]: MYJDErrorEmailNotConfirmedException,\n    [C.EXCEPTION_FAILED]: MYJDFailedException,\n    [C.EXCEPTION_FILE_NOT_FOUND]: MYJDFileNotFoundException,\n    [C.EXCEPTION_INTERNAL_SERVER_ERROR]: MYJDInternalServerErrorException,\n    [C.EXCEPTION_MAINTENANCE]: MYJDMaintenanceException,\n    [C.EXCEPTION_METHOD_FORBIDDEN]: MYJDMethodForbiddenException,\n    [C.EXCEPTION_OFFLINE]: MYJDOfflineException,\n    [C.EXCEPTION_OUTDATED]: MYJDOutdatedException,\n    [C.EXCEPTION_OVERLOAD]: MYJDOverloadException,\n    [C.EXCEPTION_SESSION]: MYJDSessionException,\n    [C.EXCEPTION_STORAGE_ALREADY_EXISTS]: MYJDStorageAlreadyExistsException,\n    [C.EXCEPTION_STORAGE_INVALID_KEY]: MYJDStorageInvalidKeyException,\n    [C.EXCEPTION_STORAGE_INVALID_STORAGEID]: MYJDStorageInvalidStorageIdException,\n    [C.EXCEPTION_STORAGE_KEY_NOT_FOUND]: MYJDStorageKeyNotFoundException,\n    [C.EXCEPTION_STORAGE_LIMIT_REACHED]: MYJDStorageLimitReachedException,\n    [C.EXCEPTION_STORAGE_NOT_FOUND]: MYJDStorageNotFoundException,\n    [C.EXCEPTION_TOKEN_INVALID]: MYJDTokenInvalidException,\n    [C.EXCEPTION_TOO_MANY_REQUESTS]: MYJDTooManyRequestsException,\n    [C.EXCEPTION_UNKNOWN]: MYJDUnknownException,\n};", "/**\n * Main logic for MyJDownloader API in Modern JS using crypto.subtle\n */\nimport {\n    MYJDException,\n    MYJDApiException,\n    MYJDConnectionException,\n    MYJDDecodeException,\n    MYJDDeviceNotFoundException\n} from './exception.js';\n\n// --- Crypto Utils ---\n/**\n * @constant\n * @type {TextEncoder}\n * @description Global TextEncoder instance for string-to-bytes conversion.\n */\nconst ENC = new TextEncoder();\n/**\n * @constant\n * @type {TextDecoder}\n * @description Global TextDecoder instance for bytes-to-string conversion.\n */\nconst DEC = new TextDecoder();\n\n/**\n * Converts an ArrayBuffer to its hexadecimal string representation.\n * @param {ArrayBuffer} buffer - The buffer to convert.\n * @returns {string} The hexadecimal string.\n */\nfunction bufferToHex(buffer) {\n    return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Converts a hexadecimal string to an ArrayBuffer.\n * @param {string} hex - The hexadecimal string.\n * @returns {ArrayBuffer} The resulting buffer.\n */\nfunction hexToBuffer(hex) {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\n    }\n    return bytes.buffer;\n}\n\n/**\n * Converts a Base64 string to an ArrayBuffer.\n * @param {string} base64 - The Base64 string.\n * @returns {ArrayBuffer} The resulting buffer.\n */\nfunction base64ToBuffer(base64) {\n    const binString = atob(base64);\n    const bytes = new Uint8Array(binString.length);\n    for (let i = 0; i < binString.length; i++) {\n        bytes[i] = binString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\n/**\n * Converts an ArrayBuffer to a Base64 string.\n * @param {ArrayBuffer} buffer - The buffer to convert.\n * @returns {string} The Base64 string.\n */\nfunction bufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\n/**\n * Concatenates multiple ArrayBuffers or Uint8Arrays into a single Uint8Array.\n * @param {...(ArrayBuffer|Uint8Array)} buffers - Buffers to concatenate.\n * @returns {Uint8Array} The concatenated buffer.\n */\nfunction concatBuffers(...buffers) {\n    const totalLen = buffers.reduce((acc, b) => acc + (b.byteLength || b.length), 0);\n    const tmp = new Uint8Array(totalLen);\n    let offset = 0;\n    for (const b of buffers) {\n        const u8 = b instanceof Uint8Array ? b : new Uint8Array(b);\n        tmp.set(u8, offset);\n        offset += u8.length;\n    }\n    return tmp;\n}\n\n// --- Classes ---\n\n/**\n * @class\n * @description Provides methods to manage JDownloader accounts (premium hoster accounts and basic authentication credentials) on a specific device.\n */\nexport class Accounts {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/accountsV2\";\n    }\n\n    /**\n     * Adds a new premium account to JDownloader.\n     * @param {string} premiumHoster - The hoster name (e.g., 'uploaded.net').\n     * @param {string} username - The username for the account.\n     * @param {string} password - The password for the account.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async addAccount(premiumHoster, username, password) {\n        const params = [premiumHoster, username, password];\n        return await this.device.action(this.url + \"/addAccount\", params);\n    }\n\n    /**\n     * Adds basic authentication credentials (e.g., for file access via HTTP/FTP).\n     * @param {string} type - The type of basic auth (e.g., 'HTTP', 'FTP').\n     * @param {string} hostmask - The host or hostmask (e.g., 'example.com').\n     * @param {string} username - The basic auth username.\n     * @param {string} password - The basic auth password.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async addBasicAuth(type, hostmask, username, password) {\n        const params = [type, hostmask, username, password];\n        return await this.device.action(this.url + \"/addBasicAuth\", params);\n    }\n\n    /**\n     * Disables the specified accounts by their IDs.\n     * @param {number[]} accountIds - List of account UUIDs (as numbers) to disable.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async disableAccounts(accountIds) {\n        const params = [accountIds];\n        return await this.device.action(this.url + \"/disableAccounts\", params);\n    }\n\n    /**\n     * Enables the specified accounts by their IDs.\n     * @param {number[]} accountIds - List of account UUIDs (as numbers) to enable.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async enableAccounts(accountIds) {\n        const params = [accountIds];\n        return await this.device.action(this.url + \"/enableAccounts\", params);\n    }\n\n    /**\n     * Retrieves the URL for a specific premium hoster login page.\n     * @param {string} hoster - The hoster name.\n     * @returns {Promise<string>} A promise that resolves to the hoster URL string.\n     */\n    async getPremiumHosterUrl(hoster) {\n        const params = [hoster];\n        return await this.device.action(this.url + \"/getPremiumHosterUrl\", params);\n    }\n\n    /**\n     * Lists all premium accounts, optionally filtering the returned data fields.\n     * @param {Object[]} [query] - An array of query objects defining what data fields to retrieve.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of account objects.\n     */\n    async listAccounts(query = [{\n        \"startAt\": 0,\n        \"maxResults\": -1,\n        \"userName\": true,\n        \"validUntil\": true,\n        \"trafficLeft\": true,\n        \"trafficMax\": true,\n        \"enabled\": true,\n        \"valid\": true,\n        \"error\": false,\n        \"UUIDList\": [],\n    }]) {\n        return await this.device.action(this.url + \"/listAccounts\", query);\n    }\n\n    /**\n     * Lists all configured basic authentication credentials.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of basic auth objects.\n     */\n    async listBasicAuth() {\n        return await this.device.action(this.url + \"/listBasicAuth\");\n    }\n\n    /**\n     * Lists all supported premium hosters.\n     * @returns {Promise<string[]>} A promise that resolves to an array of hoster names.\n     */\n    async listPremiumHoster() {\n        return await this.device.action(this.url + \"/listPremiumHoster\");\n    }\n\n    /**\n     * Lists all URLs of supported premium hosters.\n     * @returns {Promise<Object>} A promise that resolves to an object mapping hoster names to URLs.\n     */\n    async listPremiumHosterUrls() {\n        return await this.device.action(this.url + \"/listPremiumHosterUrls\");\n    }\n\n    /**\n     * Forces a refresh check for the validity/traffic of the specified accounts.\n     * @param {number[]} accountIds - List of account UUIDs (as numbers) to refresh.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async refreshAccounts(accountIds) {\n        const params = [accountIds];\n        return await this.device.action(this.url + \"/refreshAccounts\", params);\n    }\n\n    /**\n     * Removes the specified accounts by their IDs.\n     * @param {number[]} accountIds - List of account UUIDs (as numbers) to remove.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async removeAccounts(accountIds) {\n        const params = [accountIds];\n        return await this.device.action(this.url + \"/removeAccounts\", params);\n    }\n\n    /**\n     * Removes the specified basic authentication entries by their IDs.\n     * @param {number[]} accountIds - List of basic auth UUIDs (as numbers) to remove.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async removeBasicAuths(accountIds) {\n        const params = [accountIds];\n        return await this.device.action(this.url + \"/removeBasicAuths\", params);\n    }\n\n    /**\n     * Updates the username and/or password for an existing premium account.\n     * @param {number} accountId - The account UUID (as a number).\n     * @param {string} username - The new username.\n     * @param {string} password - The new password.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async setUserNameAndPassword(accountId, username, password) {\n        const params = [accountId, username, password];\n        return await this.device.action(this.url + \"/setUserNameAndPassword\", params);\n    }\n\n    /**\n     * Updates an existing basic authentication entry.\n     * @param {Object} basicAuth - The complete basic auth object with updated fields.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async updateBasicAuth(basicAuth) {\n        return await this.device.action(this.url + \"/updateBasicAuth\", basicAuth);\n    }\n}\n\n/**\n * @class\n * @description Provides methods for system-level operations on the JDownloader client (e.g., shutdown, restart, hibernation).\n */\nexport class System {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = '/system';\n    }\n\n    /**\n     * Stops JDownloader (exits the application).\n     * @returns {Promise<boolean>} A promise that resolves to true if the operation was initiated successfully.\n     */\n    async exitJD() {\n        return await this.device.action(this.url + \"/exitJD\");\n    }\n\n    /**\n     * Restarts the JDownloader application.\n     * @returns {Promise<boolean>} A promise that resolves to true if the operation was initiated successfully.\n     */\n    async restartJD() {\n        return await this.device.action(this.url + \"/restartJD\");\n    }\n\n    /**\n     * Commands the underlying operating system to hibernate (suspend to disk).\n     * @returns {Promise<boolean>} A promise that resolves to true if the operation was initiated successfully.\n     */\n    async hibernateOS() {\n        return await this.device.action(this.url + \"/hibernateOS\");\n    }\n\n    /**\n     * Commands the underlying operating system to shutdown.\n     * @param {boolean} force - If true, forces the shutdown, bypassing confirmation dialogues.\n     * @returns {Promise<boolean>} A promise that resolves to true if the operation was initiated successfully.\n     */\n    async shutdownOS(force) {\n        const params = force; \n        return await this.device.action(this.url + \"/shutdownOS\", params);\n    }\n\n    /**\n     * Commands the underlying operating system to standby (suspend to RAM).\n     * @returns {Promise<boolean>} A promise that resolves to true if the operation was initiated successfully.\n     */\n    async standbyOS() {\n        return await this.device.action(this.url + \"/standbyOS\");\n    }\n\n    /**\n     * Retrieves storage information about the file system where JDownloader is running,\n     * including free and total space.\n     * @returns {Promise<Object>} A promise that resolves to an object containing storage details.\n     */\n    async getStorageInfo() {\n        return await this.device.action(this.url + \"/getStorageInfos?path\");\n    }\n}\n\n/**\n * @class\n * @description Provides basic information about the JDownloader core itself.\n */\nexport class JD {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = '/jd';\n    }\n\n    /**\n     * Retrieves the current core revision number of the JDownloader client.\n     * @returns {Promise<number>} A promise that resolves to the core revision number.\n     */\n    async getCoreRevision() {\n        return await this.device.action(this.url + \"/getCoreRevision\");\n    }\n}\n\n/**\n * @class\n * @description Provides methods to manage JDownloader updates.\n */\nexport class Update {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = '/update';\n    }\n\n    /**\n     * Restarts JDownloader and immediately starts the update process.\n     * @returns {Promise<boolean>} A promise that resolves to true if the update was initiated.\n     */\n    async restartAndUpdate() {\n        return await this.device.action(this.url + \"/restartAndUpdate\");\n    }\n\n    /**\n     * Forces JDownloader to run a check for new updates.\n     * @returns {Promise<boolean>} A promise that resolves after the check is started.\n     */\n    async runUpdateCheck() {\n        return await this.device.action(this.url + \"/runUpdateCheck\");\n    }\n\n    /**\n     * Checks if updates are currently available after a check has been performed.\n     * @returns {Promise<boolean>} A promise that resolves to true if updates are available.\n     */\n    async isUpdateAvailable() {\n        return await this.device.action(this.url + \"/isUpdateAvailable\");\n    }\n\n    /**\n     * Runs an update check and then returns whether an update is available.\n     * @returns {Promise<boolean>} A promise that resolves to true if updates are available.\n     */\n    async updateAvailable() {\n        await this.runUpdateCheck();\n        return await this.isUpdateAvailable();\n    }\n}\n\n/**\n * @class\n * @description Provides methods to read and modify configuration settings of JDownloader.\n */\nexport class Config {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = '/config';\n    }\n\n    /**\n     * Lists all configurable settings interfaces.\n     * @param {Object} [params=null] - Optional parameters for listing.\n     * @returns {Promise<Object>} A promise that resolves to an object listing configuration interfaces.\n     */\n    async list(params = null) {\n        if (params !== null) {\n            return await this.device.action(this.url + \"/list\");\n        }\n        return await this.device.action(this.url + \"/list\", params);\n    }\n\n    /**\n     * Lists possible values for an enum configuration type.\n     * @param {string} type - The enum type name.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of possible enum values.\n     */\n    async listEnum(type) {\n        return await this.device.action(this.url + \"/listEnum\", [type]);\n    }\n\n    /**\n     * Retrieves the current value of a specific configuration key.\n     * @param {string} interfaceName - The name of the configuration interface (e.g., 'org.jdownloader.settings.GeneralSettings').\n     * @param {string} storage - The storage name (e.g., 'default').\n     * @param {string} key - The key of the configuration item.\n     * @returns {Promise<any>} A promise that resolves to the configuration value (string, number, boolean, or object).\n     */\n    async get(interfaceName, storage, key) {\n        const params = [interfaceName, storage, key];\n        return await this.device.action(this.url + \"/get\", params);\n    }\n\n    /**\n     * Retrieves the default value of a specific configuration key.\n     * @param {string} interfaceName - The name of the configuration interface.\n     * @param {string} storage - The storage name.\n     * @param {string} key - The key of the configuration item.\n     * @returns {Promise<any>} A promise that resolves to the default configuration value.\n     */\n    async getDefault(interfaceName, storage, key) {\n        const params = [interfaceName, storage, key];\n        return await this.device.action(this.url + \"/getDefault\", params);\n    }\n\n    /**\n     * Queries configuration settings based on filtering criteria.\n     * @param {Object[]} [params] - An array of query objects defining what data fields to retrieve and filter.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of matching configuration objects.\n     */\n    async query(params = [{\n        \"configInterface\": \"\",\n        \"defaultValues\": true,\n        \"description\": true,\n        \"enumInfo\": true,\n        \"includeExtensions\": true,\n        \"pattern\": \"\",\n        \"values\": true\n    }]) {\n        return await this.device.action(this.url + \"/query\", params);\n    }\n\n    /**\n     * Resets a specific configuration key to its default value.\n     * @param {string} interfaceName - The name of the configuration interface.\n     * @param {string} storage - The storage name.\n     * @param {string} key - The key of the configuration item to reset.\n     * @returns {Promise<boolean>} A promise that resolves to true upon successful reset.\n     */\n    async reset(interfaceName, storage, key) {\n        const params = [interfaceName, storage, key];\n        return await this.device.action(this.url + \"/reset\", params);\n    }\n\n    /**\n     * Sets the value of a specific configuration key.\n     * @param {string} interfaceName - The name of the configuration interface.\n     * @param {string} storage - The storage name.\n     * @param {string} key - The key of the configuration item to set.\n     * @param {any} value - The new value (string, number, boolean, or object).\n     * @returns {Promise<boolean>} A promise that resolves to true upon successful setting.\n     */\n    async set(interfaceName, storage, key, value) {\n        const params = [interfaceName, storage, key, value];\n        return await this.device.action(this.url + \"/set\", params);\n    }\n}\n\n/**\n * @class\n * @description Provides methods to control the overall download process (start, stop, pause, speed).\n */\nexport class DownloadController {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = '/downloadcontroller';\n    }\n\n    /**\n     * Starts all pending downloads in JDownloader.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async startDownloads() {\n        return await this.device.action(this.url + \"/start\");\n    }\n\n    /**\n     * Stops all active downloads in JDownloader.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async stopDownloads() {\n        return await this.device.action(this.url + \"/stop\");\n    }\n\n    /**\n     * Pauses or unpauses all downloads.\n     * @param {boolean} value - True to pause, false to unpause.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async pauseDownloads(value) {\n        const params = [value];\n        return await this.device.action(this.url + \"/pause\", params);\n    }\n\n    /**\n     * Retrieves the current aggregate download speed in Bytes per second.\n     * @returns {Promise<number>} A promise that resolves to the current download speed (Bps).\n     */\n    async getSpeedInBytes() {\n        return await this.device.action(this.url + \"/getSpeedInBps\");\n    }\n\n    /**\n     * Forces the download of specific links or packages, interrupting the current queue order.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers) to force download.\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers) to force download.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async forceDownload(linkIds, packageIds) {\n        const params = [linkIds, packageIds];\n        return await this.device.action(this.url + \"/forceDownload\", params);\n    }\n\n    /**\n     * Retrieves the current state of the download controller (e.g., 'STOPPED', 'RUNNING', 'PAUSED').\n     * @returns {Promise<string>} A promise that resolves to the current state string.\n     */\n    async getCurrentState() {\n        return await this.device.action(this.url + \"/getCurrentState\");\n    }\n}\n\n/**\n * @class\n * @description Provides methods to manage JDownloader extensions and add-ons.\n */\nexport class Extension {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/extensions\";\n    }\n\n    /**\n     * Lists all installed and available extensions, optionally filtering the returned data.\n     * @param {Object[]} [params] - An array of query objects defining data fields to retrieve.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of extension information objects.\n     */\n    async list(params = [{\n        \"configInterface\": true,\n        \"description\": true,\n        \"enabled\": true,\n        \"iconKey\": true,\n        \"name\": true,\n        \"pattern\": \"\",\n        \"installed\": true\n    }]) {\n        return await this.device.action(this.url + \"/list\", params);\n    }\n\n    /**\n     * Installs an extension by its ID (if available).\n     * @param {string} id - The unique ID of the extension to install.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async install(id) {\n        return await this.device.action(this.url + \"/install\", [id]);\n    }\n\n    /**\n     * Checks if a specific extension is installed.\n     * @param {string} id - The unique ID of the extension.\n     * @returns {Promise<boolean>} A promise that resolves to true if the extension is installed.\n     */\n    async isInstalled(id) {\n        return await this.device.action(this.url + \"/isInstalled\", [id]);\n    }\n\n    /**\n     * Checks if a specific extension is currently enabled.\n     * @param {string} id - The unique ID of the extension.\n     * @returns {Promise<boolean>} A promise that resolves to true if the extension is enabled.\n     */\n    async isEnabled(id) {\n        return await this.device.action(this.url + \"/isEnabled\", [id]);\n    }\n\n    /**\n     * Enables or disables a specific extension.\n     * @param {string} id - The unique ID of the extension.\n     * @param {boolean} enabled - True to enable, false to disable.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async setEnabled(id, enabled) {\n        return await this.device.action(this.url + \"/setEnabled\", [id, enabled]);\n    }\n}\n\n/**\n * @class\n * @description Provides methods to manage JDownloader dialogs (e.g., captchas, configuration prompts) that require user interaction.\n */\nexport class Dialog {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/dialogs\";\n    }\n\n    /**\n     * Submits an answer to a pending dialog/prompt.\n     * @param {number} id - The ID of the dialog to answer.\n     * @param {Object} data - The answer data object specific to the dialog type.\n     * @returns {Promise<boolean>} A promise that resolves to true if the answer was submitted.\n     */\n    async answer(id, data) {\n        return await this.device.action(this.url + \"/answer\", [id, data]);\n    }\n\n    /**\n     * Retrieves detailed information about a specific dialog, optionally including the icon and properties.\n     * @param {number} id - The ID of the dialog.\n     * @param {boolean} [icon=true] - Whether to retrieve icon data.\n     * @param {boolean} [properties=true] - Whether to retrieve properties data.\n     * @returns {Promise<Object>} A promise that resolves to the detailed dialog object.\n     */\n    async get(id, icon = true, properties = true) {\n        return await this.device.action(this.url + \"/get\", [id, icon, properties]);\n    }\n\n    /**\n     * Retrieves static information about a specific dialog type.\n     * @param {string} dialogType - The type identifier of the dialog.\n     * @returns {Promise<Object>} A promise that resolves to the type information object.\n     */\n    async getTypeInfo(dialogType) {\n        return await this.device.action(this.url + \"/getTypeInfo\", [dialogType]);\n    }\n\n    /**\n     * Lists all currently active dialogs waiting for user input.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of active dialog objects.\n     */\n    async list() {\n        return await this.device.action(this.url + \"/list\");\n    }\n}\n\n/**\n * @class\n * @description Provides methods to manage the Linkgrabber tab (the area where links are collected and analyzed before being added to the download queue).\n */\nexport class Linkgrabber {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = '/linkgrabberv2';\n    }\n\n    /**\n     * Clears all links and packages from the Linkgrabber list.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async clearList() {\n        return await this.device.action(this.url + \"/clearList\", [], \"POST\");\n    }\n\n    /**\n     * Moves specific links and/or packages from the Linkgrabber to the Download List.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers) to move.\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers) to move.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async moveToDownloadList(linkIds, packageIds) {\n        const params = [linkIds, packageIds];\n        return await this.device.action(this.url + \"/moveToDownloadlist\", params);\n    }\n\n    /**\n     * Queries specific links within the Linkgrabber packages, optionally filtering the returned data fields.\n     * @param {Object[]} [params] - An array of query objects defining what data fields to retrieve.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of link objects.\n     */\n    async queryLinks(params = [{\n        \"bytesTotal\": true,\n        \"comment\": true,\n        \"status\": true,\n        \"enabled\": true,\n        \"maxResults\": -1,\n        \"startAt\": 0,\n        \"hosts\": true,\n        \"url\": true,\n        \"availability\": true,\n        \"variantIcon\": true,\n        \"variantName\": true,\n        \"variantID\": true,\n        \"variants\": true,\n        \"priority\": true\n    }]) {\n        return await this.device.action(this.url + \"/queryLinks\", params);\n    }\n\n    /**\n     * Cleans up the Linkgrabber list based on defined criteria (e.g., removing duplicates, offline links).\n     * @param {string} action - The cleanup action to perform.\n     * @param {string} mode - The cleanup mode.\n     * @param {string} selectionType - Defines if cleanup applies to links, packages, or both.\n     * @param {number[]} [linkIds] - Optional array of specific link UUIDs to target.\n     * @param {number[]} [packageIds] - Optional array of specific package UUIDs to target.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async cleanup(action, mode, selectionType, linkIds = [], packageIds = []) {\n        let params = [linkIds, packageIds];\n        params = params.concat([action, mode, selectionType]);\n        return await this.device.action(this.url + \"/cleanup\", params);\n    }\n\n    /**\n     * Adds a link container file (e.g., DLC, CCF, RSDF content as a base64 string) to the Linkgrabber.\n     * @param {string} type_ - The type of container (e.g., 'DLC', 'TEXT').\n     * @param {string} content - The file content (usually Base64 encoded).\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async addContainer(type_, content) {\n        const params = [type_, content];\n        return await this.device.action(this.url + \"/addContainer\", params);\n    }\n\n    /**\n     * Retrieves the final download URLs for specified links or packages.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers).\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers).\n     * @param {string} urlDisplayType - Specifies the format of the returned URL.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of URL objects.\n     */\n    async getDownloadUrls(linkIds, packageIds, urlDisplayType) {\n        const params = [packageIds, linkIds, urlDisplayType];\n        return await this.device.action(this.url + \"/getDownloadUrls\", params);\n    }\n\n    /**\n     * Sets the priority for specified links or packages in the Linkgrabber.\n     * @param {string} priority - The new priority (e.g., 'DEFAULT', 'HIGH', 'LOW').\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers).\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers).\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async setPriority(priority, linkIds, packageIds) {\n        const params = [priority, linkIds, packageIds];\n        return await this.device.action(this.url + \"/setPriority\", params);\n    }\n\n    /**\n     * Enables or disables specified links or packages in the Linkgrabber.\n     * @param {boolean} enable - True to enable, false to disable.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers).\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers).\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async setEnabled(enable, linkIds, packageIds) {\n        const params = [enable, linkIds, packageIds];\n        return await this.device.action(this.url + \"/setEnabled\", params);\n    }\n\n    /**\n     * Retrieves available variants (e.g., different file mirrors or download options) for links/packages.\n     * @param {Object} params - Query parameters to select links/packages.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of link variant objects.\n     */\n    async getVariants(params) {\n        return await this.device.action(this.url + \"/getVariants\", params);\n    }\n\n    /**\n     * Adds raw links to the Linkgrabber, providing package and configuration details.\n     * @param {Object[]} [params] - An array of link objects containing links, package name, passwords, etc.\n     * @returns {Promise<Object>} A promise that resolves to the API response object.\n     */\n    async addLinks(params = [{\n        \"autostart\": false,\n        \"links\": null,\n        \"packageName\": null,\n        \"extractPassword\": null,\n        \"priority\": \"DEFAULT\",\n        \"downloadPassword\": null,\n        \"destinationFolder\": null,\n        \"overwritePackagizerRules\": false\n    }]) {\n        return await this.device.action(\"/linkgrabberv2/addLinks\", params);\n    }\n\n    /**\n     * Checks if the Linkgrabber is currently busy collecting or analyzing links.\n     * @returns {Promise<boolean>} A promise that resolves to true if collecting is in progress.\n     */\n    async isCollecting() {\n        return await this.device.action(this.url + \"/isCollecting\");\n    }\n\n    /**\n     * Removes specified links or packages from the Linkgrabber list.\n     * @param {number[]} [linkIds] - Array of link UUIDs (as numbers) to remove.\n     * @param {number[]} [packageIds] - Array of package UUIDs (as numbers) to remove.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async removeLinks(linkIds = [], packageIds = []) {\n        const params = [linkIds, packageIds];\n        return await this.device.action(this.url + \"/removeLinks\", params);\n    }\n\n    /**\n     * Retrieves the count of packages currently in the Linkgrabber.\n     * @returns {Promise<number>} A promise that resolves to the package count.\n     */\n    async getPackageCount() {\n        return await this.device.action(\"/linkgrabberv2/getPackageCount\");\n    }\n\n    /**\n     * Renames a specific package in the Linkgrabber.\n     * @param {number} packageId - The UUID of the package to rename.\n     * @param {string} newName - The new name for the package.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async renamePackage(packageId, newName) {\n        const params = [packageId, newName];\n        return await this.device.action(this.url + \"/renamePackage\", params);\n    }\n\n    /**\n     * Queries packages in the Linkgrabber, optionally filtering the returned data fields.\n     * @param {Object[]} [params] - An array of query objects defining what data fields to retrieve.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of package objects.\n     */\n    async queryPackages(params = [{\n        \"availableOfflineCount\": true,\n        \"availableOnlineCount\": true,\n        \"availableTempUnknownCount\": true,\n        \"availableUnknownCount\": true,\n        \"bytesTotal\": true,\n        \"childCount\": true,\n        \"comment\": true,\n        \"enabled\": true,\n        \"hosts\": true,\n        \"maxResults\": -1,\n        \"packageUUIDs\": [],\n        \"priority\": true,\n        \"saveTo\": true,\n        \"startAt\": 0,\n        \"status\": true\n    }]) {\n        return await this.device.action(this.url + \"/queryPackages\", params);\n    }\n\n    /**\n     * Renames a specific link within a package.\n     * @param {number} linkId - The UUID of the link to rename.\n     * @param {string} newName - The new name for the link.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async renameLink(linkId, newName) {\n        const params = [linkId, newName];\n        return await this.device.action(this.url + \"/renameLink\", params);\n    }\n\n    /**\n     * Moves specified links into a brand new package with a defined name and path.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers) to move.\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers) to move.\n     * @param {string} newPkgName - The name of the new package.\n     * @param {string} downloadPath - The download path for the new package.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async moveToNewPackage(linkIds, packageIds, newPkgName, downloadPath) {\n        const params = [linkIds, packageIds, newPkgName, downloadPath];\n        return await this.device.action(this.url + \"/movetoNewPackage\", params);\n    }\n\n    /**\n     * Retrieves the API help documentation for the Linkgrabber V2 interface.\n     * @returns {Promise<Object>} A promise that resolves to the help documentation object.\n     */\n    async help() {\n        return await this.device.action(\"/linkgrabberv2/help\", [], \"GET\");\n    }\n    \n    // NOTE: Other methods from the original structure (e.g., getChildrenChanged, getDownFolderHistorySelectBase, moveLinks, setVariant, movePackages, addVariantCopy) are implicitly omitted as they were not implemented in the base JS code.\n}\n\n/**\n * @class\n * @description Provides methods to manage the Downloads tab (the main download queue).\n */\nexport class Downloads {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/downloadsV2\";\n    }\n\n    /**\n     * Queries links within the download packages, optionally filtering the returned data fields.\n     * @param {Object[]} [params] - An array of query objects defining what data fields to retrieve.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of link objects in the download queue.\n     */\n    async queryLinks(params = [{\n        \"addedDate\": true,\n        \"bytesLoaded\": true,\n        \"bytesTotal\": true,\n        \"comment\": true,\n        \"enabled\": true,\n        \"eta\": true,\n        \"extractionStatus\": true,\n        \"finished\": true,\n        \"finishedDate\": true,\n        \"host\": true,\n        \"jobUUIDs\": [],\n        \"maxResults\": -1,\n        \"packageUUIDs\": [],\n        \"password\": true,\n        \"priority\": true,\n        \"running\": true,\n        \"skipped\": true,\n        \"speed\": true,\n        \"startAt\": 0,\n        \"status\": true,\n        \"url\": true\n    }]) {\n        return await this.device.action(this.url + \"/queryLinks\", params);\n    }\n\n    /**\n     * Queries packages in the download list, optionally filtering the returned data fields.\n     * @param {Object[]} [params] - An array of query objects defining what data fields to retrieve.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of package objects in the download queue.\n     */\n    async queryPackages(params = [{\n        \"bytesLoaded\": true,\n        \"bytesTotal\": true,\n        \"childCount\": true,\n        \"comment\": true,\n        \"enabled\": true,\n        \"eta\": true,\n        \"finished\": true,\n        \"hosts\": true,\n        \"maxResults\": -1,\n        \"packageUUIDs\": [],\n        \"priority\": true,\n        \"running\": true,\n        \"saveTo\": true,\n        \"speed\": true,\n        \"startAt\": 0,\n        \"status\": true\n    }]) {\n        return await this.device.action(this.url + \"/queryPackages\", params);\n    }\n\n    /**\n     * Cleans up the Download list based on defined criteria (e.g., removing completed, failed, or offline links).\n     * @param {string} action - The cleanup action to perform.\n     * @param {string} mode - The cleanup mode.\n     * @param {string} selectionType - Defines if cleanup applies to links, packages, or both.\n     * @param {number[]} [linkIds] - Optional array of specific link UUIDs to target.\n     * @param {number[]} [packageIds] - Optional array of specific package UUIDs to target.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async cleanup(action, mode, selectionType, linkIds = [], packageIds = []) {\n        let params = [linkIds, packageIds];\n        params = params.concat([action, mode, selectionType]);\n        return await this.device.action(this.url + \"/cleanup\", params);\n    }\n\n    /**\n     * Enables or disables specified links or packages in the download list.\n     * @param {boolean} enable - True to enable, false to disable.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers).\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers).\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async setEnabled(enable, linkIds, packageIds) {\n        const params = [enable, linkIds, packageIds];\n        return await this.device.action(this.url + \"/setEnabled\", params);\n    }\n\n    /**\n     * Forces the download of specific links or packages, interrupting the current queue order.\n     * @param {number[]} [linkIds] - Array of link UUIDs (as numbers) to force download.\n     * @param {number[]} [packageIds] - Array of package UUIDs (as numbers) to force download.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async forceDownload(linkIds = [], packageIds = []) {\n        const params = [linkIds, packageIds];\n        return await this.device.action(this.url + \"/forceDownload\", params);\n    }\n\n    /**\n     * Sets the download directory for specified packages.\n     * @param {string} directory - The new absolute download path.\n     * @param {number[]} [packageIds] - Array of package UUIDs (as numbers) to update.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async setDlLocation(directory, packageIds = []) {\n        const params = [directory, packageIds];\n        return await this.device.action(this.url + \"/setDownloadDirectory\", params);\n    }\n\n    /**\n     * Removes specified links or packages from the download list (moving them to the trash).\n     * @param {number[]} [linkIds] - Array of link UUIDs (as numbers) to remove.\n     * @param {number[]} [packageIds] - Array of package UUIDs (as numbers) to remove.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async removeLinks(linkIds = [], packageIds = []) {\n        const params = [linkIds, packageIds];\n        return await this.device.action(this.url + \"/removeLinks\", params);\n    }\n\n    /**\n     * Resets the download status of specified links/packages, allowing them to be downloaded again.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers) to reset.\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers) to reset.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async resetLinks(linkIds, packageIds) {\n        const params = [linkIds, packageIds];\n        return await this.device.action(this.url + \"/resetLinks\", params);\n    }\n\n    /**\n     * Moves specified links into a brand new package within the download list.\n     * @param {number[]} linkIds - Array of link UUIDs (as numbers) to move.\n     * @param {number[]} packageIds - Array of package UUIDs (as numbers) to move.\n     * @param {string} newPkgName - The name of the new package.\n     * @param {string} downloadPath - The download path for the new package.\n     * @returns {Promise<boolean>} A promise that resolves to true upon success.\n     */\n    async moveToNewPackage(linkIds, packageIds, newPkgName, downloadPath) {\n        const params = [linkIds, packageIds, newPkgName, downloadPath];\n        return await this.device.action(this.url + \"/movetoNewPackage\", params);\n    }\n}\n\n/**\n * @class\n * @description Provides methods to handle Captcha challenges requested by hosters.\n */\nexport class Captcha {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/captcha\";\n    }\n\n    /**\n     * Lists all pending captcha challenges waiting for a solution.\n     * @returns {Promise<Object[]>} A promise that resolves to an array of captcha objects.\n     */\n    async list() {\n        return await this.device.action(this.url + \"/list\", []);\n    }\n\n    /**\n     * Retrieves detailed information, including the image (Base64 encoded), for a specific captcha challenge.\n     * @param {number} captchaId - The ID of the captcha challenge.\n     * @returns {Promise<Object>} A promise that resolves to the detailed captcha object.\n     */\n    async get(captchaId) {\n        return await this.device.action(this.url + \"/get\", [captchaId]);\n    }\n\n    /**\n     * Submits a solution for a specific captcha challenge.\n     * @param {number} captchaId - The ID of the captcha challenge.\n     * @param {string} solution - The text solution for the captcha.\n     * @returns {Promise<boolean>} A promise that resolves to true upon successful submission.\n     */\n    async solve(captchaId, solution) {\n        return await this.device.action(this.url + \"/solve\", [captchaId, solution]);\n    }\n}\n\n/**\n * @class\n * @description Provides methods for controlling the reconnection process (used to get a new IP address).\n */\nexport class Reconnect {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/reconnect\";\n    }\n\n    /**\n     * Forces JDownloader to execute the configured reconnection method.\n     * @returns {Promise<boolean>} A promise that resolves to true if the reconnection was initiated.\n     */\n    async doReconnect() {\n        return await this.device.action(this.url + \"/doReconnect\");\n    }\n}\n\n/**\n * @class\n * @description Provides access to the JDownloader GUI toolbar status and controls.\n */\nexport class Toolbar {\n    /**\n     * @constructor\n     * @param {JDDevice} device - The JDDevice instance this controller is bound to.\n     */\n    constructor(device) {\n        /** @type {JDDevice} */\n        this.device = device;\n        /** @type {string} */\n        this.url = \"/toolbar\";\n        /** @type {Object | null} */\n        this.status = null;\n    }\n\n    /**\n     * Retrieves the current status of the toolbar elements, including speed limit state.\n     * @param {Object} [params=null] - Optional query parameters.\n     * @returns {Promise<Object>} A promise that resolves to the toolbar status object.\n     */\n    async getStatus(params = null) {\n        return await this.device.action(this.url + \"/getStatus\");\n    }\n\n    /**\n     * Internal method to determine if the download speed limit is currently active.\n     * @returns {Promise<number>} A promise that resolves to 1 if the limit is enabled, 0 otherwise.\n     */\n    async statusDownloadSpeedLimit() {\n        this.status = await this.getStatus();\n        return this.status['limit'] ? 1 : 0;\n    }\n\n    /**\n     * Enables the configured download speed limit.\n     * @returns {Promise<void>}\n     */\n    async enableDownloadSpeedLimit() {\n        this.limitEnabled = await this.statusDownloadSpeedLimit();\n        if (!this.limitEnabled) {\n            await this.device.action(this.url + \"/toggleDownloadSpeedLimit\");\n        }\n    }\n\n    /**\n     * Disables the configured download speed limit.\n     * @returns {Promise<void>}\n     */\n    async disableDownloadSpeedLimit() {\n        this.limitEnabled = await this.statusDownloadSpeedLimit();\n        if (this.limitEnabled) {\n            await this.device.action(this.url + \"/toggleDownloadSpeedLimit\");\n        }\n    }\n}\n\n\n/**\n * @class\n * @description Represents a single JDownloader client instance (a device) accessible through MyJDownloader.\n * It encapsulates all device-specific API controllers (Accounts, Linkgrabber, etc.) and handles direct vs. remote connection logic.\n */\nexport class JDDevice {\n    /**\n     * @constructor\n     * @param {MyJDApi} jd - The main MyJDApi instance.\n     * @param {Object} deviceDict - The raw device information object from the MyJDApi `listdevices` response.\n     */\n    constructor(jd, deviceDict) {\n        /** @type {string} */\n        this.name = deviceDict[\"name\"];\n        /** @type {string} */\n        this.deviceId = deviceDict[\"id\"];\n        /** @type {string} */\n        this.deviceType = deviceDict[\"type\"];\n        /** @type {MyJDApi} */\n        this.myJD = jd;\n\n        // Initialize controllers\n        /** @type {Accounts} */\n        this.accounts = new Accounts(this);\n        /** @type {Config} */\n        this.config = new Config(this);\n        /** @type {Linkgrabber} */\n        this.linkgrabber = new Linkgrabber(this);\n        /** @type {Captcha} */\n        this.captcha = new Captcha(this);\n        /** @type {Downloads} */\n        this.downloads = new Downloads(this);\n        /** @type {Toolbar} */\n        this.toolbar = new Toolbar(this);\n        /** @type {DownloadController} */\n        this.downloadcontroller = new DownloadController(this);\n        /** @type {Extension} */\n        this.extensions = new Extension(this);\n        /** @type {Dialog} */\n        this.dialogs = new Dialog(this);\n        /** @type {Reconnect} */\n        this.reconnect = new Reconnect(this);\n        /** @type {Update} */\n        this.update = new Update(this);\n        /** @type {System} */\n        this.system = new System(this);\n        /** @type {Object[] | null} */\n        this._directConnectionInfo = null;\n        /** @type {boolean} */\n        this._directConnectionEnabled = true;\n        /** @type {number} */\n        this._directConnectionCooldown = 0;\n        /** @type {number} */\n        this._directConnectionConsecutiveFailures = 0;\n        \n        // Init async background refresh\n        this._refreshDirectConnections();\n    }\n\n    /**\n     * Retrieves the current direct connection details (IP, port) from the MyJDownloader server.\n     * This is crucial for attempting local/direct communication instead of routing everything through the MyJDownloader cloud.\n     * @private\n     * @returns {Promise<void>}\n     */\n    async _refreshDirectConnections() {\n        if (this.myJD.getConnectionType() === \"remoteapi\") {\n            return;\n        }\n        const response = await this.myJD.requestApi(\"/device/getDirectConnectionInfos\",\n            \"POST\", null, this._actionUrl());\n        \n        if (response && response['data'] && response['data']['infos'] && response['data']['infos'].length !== 0) {\n            this._updateDirectConnections(response['data']['infos']);\n        }\n    }\n\n    /**\n     * Updates the internal list of direct connection information, managing cooldown status.\n     * @private\n     * @param {Object[]} directInfo - New list of direct connection objects.\n     * @returns {void}\n     */\n    _updateDirectConnections(directInfo) {\n        let tmp = [];\n        if (this._directConnectionInfo === null) {\n            for (const conn of directInfo) {\n                tmp.push({'conn': conn, 'cooldown': 0});\n            }\n            this._directConnectionInfo = tmp;\n            return;\n        }\n\n        this._directConnectionInfo = this._directConnectionInfo.filter(i => {\n             const exists = directInfo.some(d => JSON.stringify(d) === JSON.stringify(i['conn']));\n             if(exists) {\n                 directInfo = directInfo.filter(d => JSON.stringify(d) !== JSON.stringify(i['conn']));\n                 return true;\n             }\n             return false;\n        });\n\n        for (const conn of directInfo) {\n            this._directConnectionInfo.push({'conn': conn, 'cooldown': 0});\n        }\n    }\n\n    /**\n     * Enables attempts to connect directly to the JDownloader client, bypassing the cloud API when possible.\n     * @returns {Promise<void>}\n     */\n    async enableDirectConnection() {\n        this._directConnectionEnabled = true;\n        await this._refreshDirectConnections();\n    }\n\n    /**\n     * Disables the direct connection attempts, forcing all communication through the MyJDownloader cloud API.\n     * @returns {void}\n     */\n    disableDirectConnection() {\n        this._directConnectionEnabled = false;\n        this._directConnectionInfo = null;\n    }\n\n    /**\n     * Performs an action (API command) on the JDownloader device. This method handles encryption,\n     * action URL generation, and attempts direct connection if enabled before falling back to the cloud.\n     * @param {string} path - The specific API endpoint path (e.g., '/linkgrabberv2/queryLinks').\n     * @param {any[]} [params] - Array of parameters for the API command.\n     * @param {string} [httpAction='POST'] - The HTTP method to use (usually 'POST' for device actions).\n     * @returns {Promise<Object>} A promise that resolves to the 'data' part of the decrypted API response.\n     * @throws {MYJDConnectionException|MYJDApiException}\n     */\n    async action(path, params = [], httpAction = \"POST\") {\n        let actionUrl = null;\n        if (this.myJD.getConnectionType() !== \"remoteapi\") {\n            actionUrl = this._actionUrl();\n        }\n\n        const now = Date.now() / 1000;\n\n        // 1. Check for direct connection feasibility\n        if (!this._directConnectionEnabled || this._directConnectionInfo === null || now < this._directConnectionCooldown) {\n            // Fallback to cloud API\n            const response = await this.myJD.requestApi(path, httpAction, params, actionUrl);\n            if (response === null) {\n                throw new MYJDConnectionException(\"No connection established\\n\");\n            } else {\n                if (this._directConnectionEnabled && Date.now() / 1000 >= this._directConnectionCooldown) {\n                    await this._refreshDirectConnections();\n                }\n                return response['data'];\n            }\n        } else {\n            // 2. Attempt direct connection\n            for (let i = 0; i < this._directConnectionInfo.length; i++) {\n                const conn = this._directConnectionInfo[i];\n                if (Date.now() / 1000 > conn['cooldown']) {\n                    const connection = conn['conn'];\n                    const api = \"http://\" + connection[\"ip\"] + \":\" + connection[\"port\"];\n                    const response = await this.myJD.requestApi(path, httpAction, params, actionUrl, api);\n                    \n                    if (response !== null) {\n                        // Success: move to front of list and reset error state\n                        this._directConnectionInfo.splice(i, 1);\n                        this._directConnectionInfo.unshift(conn);\n                        this._directConnectionConsecutiveFailures = 0;\n                        return response['data'];\n                    } else {\n                        // Failure: apply cooldown for 60 seconds\n                        conn['cooldown'] = (Date.now() / 1000) + 60;\n                    }\n                }\n            }\n\n            // 3. Direct connection failed for all addresses, fall back to cloud API and apply cooldown\n            this._directConnectionConsecutiveFailures += 1;\n            // Increase cooldown duration exponentially based on consecutive failures\n            this._directConnectionCooldown = (Date.now() / 1000) + (60 * this._directConnectionConsecutiveFailures);\n\n            const response = await this.myJD.requestApi(path, httpAction, params, actionUrl);\n            if (response === null) {\n                throw new MYJDConnectionException(\"No connection established\\n\");\n            }\n            await this._refreshDirectConnections(); // Refresh direct info after cloud success\n            return response['data'];\n        }\n    }\n\n    /**\n     * Creates the unique action URL path required for sending encrypted commands to the device\n     * via the MyJDownloader cloud endpoint.\n     * @private\n     * @returns {string} The formatted action URL part: '/t_<sessionToken>_<deviceId>'.\n     */\n    _actionUrl() {\n        return \"/t_\" + this.myJD.getSessionToken() + \"_\" + this.deviceId;\n    }\n}\n\n/**\n * @class\n * @description The main client class for interacting with the MyJDownloader API.\n * It manages authentication, encryption keys, sessions, and device discovery.\n */\nexport class MyJDApi {\n    /**\n     * @constructor\n     */\n    constructor() {\n        /** @type {number} */\n        this._requestId = Date.now();\n        /** @type {string} */\n        this._apiUrl = \"https://api.jdownloader.org\";\n        /** @type {string} */\n        this._appKey = \"http://git.io/vmcsk\";\n        /** @type {string} */\n        this._contentType = \"application/aesjson-jd; charset=utf-8\";\n        /** @type {number} */\n        this._apiVersion = 1;\n        /** @type {Object[] | null} */\n        this._devices = null;\n        /** @type {ArrayBuffer | null} */\n        this._loginSecret = null;\n        /** @type {ArrayBuffer | null} */\n        this._deviceSecret = null;\n        /** @type {string | null} */\n        this._sessionToken = null;\n        /** @type {string | null} */\n        this._regainToken = null;\n        /** @type {ArrayBuffer | null} */\n        this._serverEncryptionToken = null;\n        /** @type {ArrayBuffer | null} */\n        this._deviceEncryptionToken = null;\n        /** @type {boolean} */\n        this._connected = false;\n        /** @type {number} */\n        this._timeout = 3000;\n        /** @type {('myjd' | 'remoteapi')} */\n        this._connectionType = \"myjd\";\n    }\n\n    /**\n     * Retrieves the current session token.\n     * @returns {string | null} The active session token.\n     */\n    getSessionToken() {\n        return this._sessionToken;\n    }\n\n    /**\n     * Checks if a connection (cloud or direct) is currently established.\n     * @returns {boolean} True if connected, false otherwise.\n     */\n    isConnected() {\n        return this._connected;\n    }\n\n    /**\n     * Sets a custom application key for API requests.\n     * @param {string} appKey - The new application key.\n     * @returns {void}\n     */\n    setAppKey(appKey) {\n        this._appKey = appKey;\n    }\n\n    /**\n     * Creates a cryptographic secret (key) used for authentication and token generation.\n     * This uses SHA-256 hash of the concatenated lowercased email, password, and domain string.\n     * @private\n     * @param {string} email - The user's email.\n     * @param {string} password - The user's password.\n     * @param {string} domain - The domain ('server' for login secret, 'device' for device secret).\n     * @returns {Promise<ArrayBuffer>} A promise that resolves to the 32-byte SHA-256 hash buffer.\n     */\n    async _secretCreate(email, password, domain) {\n        const data = ENC.encode(email.toLowerCase() + password + domain.toLowerCase());\n        const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n        return hashBuffer;\n    }\n\n    /**\n     * Generates the new server and device encryption tokens after a successful connect or reconnect.\n     * These are based on the session token and the respective base secrets (`_loginSecret` or `_deviceSecret`).\n     * @private\n     * @returns {Promise<void>}\n     */\n    async _updateEncryptionTokens() {\n        if (this._connectionType === \"remoteapi\") return;\n\n        let oldToken;\n        // Server encryption token update\n        if (this._serverEncryptionToken === null) {\n            oldToken = this._loginSecret; // Use login secret for the first token\n        } else {\n            oldToken = this._serverEncryptionToken; // Use the previous token for subsequent updates (reconnect)\n        }\n\n        const sessionTokenBuffer = hexToBuffer(this._sessionToken);\n        \n        // serverEncryptionToken = SHA-256(oldToken + sessionToken)\n        let input = concatBuffers(oldToken, sessionTokenBuffer);\n        this._serverEncryptionToken = await crypto.subtle.digest('SHA-256', input);\n\n        // deviceEncryptionToken = SHA-256(deviceSecret + sessionToken)\n        input = concatBuffers(this._deviceSecret, sessionTokenBuffer);\n        this._deviceEncryptionToken = await crypto.subtle.digest('SHA-256', input);\n    }\n\n    /**\n     * Generates the HMAC-SHA256 signature required for GET requests to the MyJDownloader cloud API.\n     * @private\n     * @param {ArrayBuffer} keyBuffer - The encryption key (login or server encryption token).\n     * @param {string} data - The raw URL query string (without the signature part).\n     * @returns {Promise<string>} A promise that resolves to the hexadecimal representation of the signature.\n     */\n    async _signatureCreate(keyBuffer, data) {\n        const key = await crypto.subtle.importKey(\n            \"raw\", \n            keyBuffer, \n            { name: \"HMAC\", hash: \"SHA-256\" }, \n            false, \n            [\"sign\"]\n        );\n        const signature = await crypto.subtle.sign(\"HMAC\", key, ENC.encode(data));\n        return bufferToHex(signature);\n    }\n\n    /**\n     * Decrypts AES-CBC encrypted data received from the API using a specific secret token.\n     * The first half of the secret token is used as the Initialization Vector (IV).\n     * @private\n     * @param {ArrayBuffer} secretTokenBuffer - The 32-byte token (server or device encryption token).\n     * @param {string} dataBase64 - The Base64 encoded, encrypted payload.\n     * @returns {Promise<string>} A promise that resolves to the decrypted JSON string.\n     */\n    async _decrypt(secretTokenBuffer, dataBase64) {\n        if (this._connectionType === \"remoteapi\") {\n            return dataBase64; \n        }\n\n        const secretToken = new Uint8Array(secretTokenBuffer);\n        const half = Math.floor(secretToken.length / 2);\n        const initVector = secretToken.slice(0, half); // First 16 bytes as IV\n        const keyRaw = secretToken.slice(half); // Last 16 bytes as Key\n\n        const key = await crypto.subtle.importKey(\"raw\", keyRaw, { name: \"AES-CBC\" }, false, [\"decrypt\"]);\n        const encryptedData = base64ToBuffer(dataBase64);\n\n        const decryptedBuffer = await crypto.subtle.decrypt(\n            { name: \"AES-CBC\", iv: initVector },\n            key,\n            encryptedData\n        );\n\n        return DEC.decode(decryptedBuffer);\n    }\n\n    /**\n     * Encrypts a JSON payload using AES-CBC encryption and a specific secret token.\n     * @private\n     * @param {ArrayBuffer} secretTokenBuffer - The 32-byte token (usually the device encryption token).\n     * @param {string} dataStr - The raw JSON string to encrypt.\n     * @returns {Promise<string>} A promise that resolves to the Base64 encoded, encrypted payload.\n     */\n    async _encrypt(secretTokenBuffer, dataStr) {\n        if (this._connectionType === \"remoteapi\") {\n            return dataStr;\n        }\n\n        const secretToken = new Uint8Array(secretTokenBuffer);\n        const half = Math.floor(secretToken.length / 2);\n        const initVector = secretToken.slice(0, half); // First 16 bytes as IV\n        const keyRaw = secretToken.slice(half); // Last 16 bytes as Key\n\n        const key = await crypto.subtle.importKey(\"raw\", keyRaw, { name: \"AES-CBC\" }, false, [\"encrypt\"]);\n        const encodedData = ENC.encode(dataStr);\n\n        const encryptedBuffer = await crypto.subtle.encrypt(\n            { name: \"AES-CBC\", iv: initVector },\n            key,\n            encodedData\n        );\n\n        return bufferToBase64(encryptedBuffer);\n    }\n\n    /**\n     * Updates the request ID (rid) to the current timestamp. This ID is used for tracking requests\n     * and preventing replay attacks.\n     * @returns {void}\n     */\n    updateRequestId() {\n        this._requestId = Date.now();\n    }\n\n    /**\n     * Establishes a connection to the MyJDownloader cloud API using email and password.\n     * This performs key derivation and fetches the initial session and regain tokens.\n     * @param {string} email - The MyJDownloader account email.\n     * @param {string} password - The MyJDownloader account password.\n     * @returns {Promise<Object>} A promise that resolves to the initial connection response, containing tokens.\n     * @throws {MYJDConnectionException|MYJDApiException}\n     */\n    async connect(email, password) {\n        this.updateRequestId();\n        // Reset all internal state and tokens\n        this._loginSecret = null;\n        this._deviceSecret = null;\n        this._sessionToken = null;\n        this._regainToken = null;\n        this._serverEncryptionToken = null;\n        this._deviceEncryptionToken = null;\n        this._devices = null;\n        this._connected = false;\n        this._connectionType = \"myjd\";\n\n        // Derive base secrets\n        this._loginSecret = await this._secretCreate(email, password, \"server\");\n        this._deviceSecret = await this._secretCreate(email, password, \"device\");\n\n        const response = await this.requestApi(\"/my/connect\", \"GET\", [\n            [\"email\", email],\n            [\"appkey\", this._appKey]\n        ]);\n\n        this._connected = true;\n        this.updateRequestId();\n        this._sessionToken = response[\"sessiontoken\"];\n        this._regainToken = response[\"regaintoken\"];\n        await this._updateEncryptionTokens();\n        await this.updateDevices();\n        return response;\n    }\n\n    /**\n     * Establishes a direct connection to a JDownloader client via its IP and optional port.\n     * This bypasses the MyJDownloader cloud entirely.\n     * @param {string} ip - The IP address of the JDownloader client.\n     * @param {number} [port=3128] - The port of the JDownloader client's API.\n     * @param {number} [timeout=3000] - The connection timeout in milliseconds.\n     * @returns {Promise<Object>} A promise that resolves to the API response object (usually { message: 'pong' }).\n     * @throws {MYJDConnectionException|MYJDApiException}\n     */\n    async directConnect(ip, port = 3128, timeout = 3000) {\n        this.updateRequestId();\n        // Reset tokens (not needed for direct connect)\n        this._loginSecret = null;\n        this._deviceSecret = null;\n        this._sessionToken = null;\n        this._regainToken = null;\n        this._serverEncryptionToken = null;\n        this._deviceEncryptionToken = null;\n\n        // Configure for remoteapi type\n        this._devices = [{\n            'name': ip,\n            'id': 'direct',\n            'type': 'jd'\n        }];\n        this._connectionType = \"remoteapi\";\n        this._apiUrl = \"http://\" + ip + \":\" + port;\n        this._contentType = \"application/json; charset=utf-8\"; // Direct connect does not use AES/JSON payload\n        this._timeout = timeout;\n        this._connected = true; \n        \n        // Attempt a ping to confirm connection\n        const respFull = await this.requestApi(\"/device/ping\", \"GET\", []);\n        const response = respFull['data'];\n        \n        this._connected = !!response;\n        this.updateRequestId();\n        return response;\n    }\n\n    /**\n     * Reconnects to the MyJDownloader cloud API using the regain token to refresh the session.\n     * @returns {Promise<Object>} A promise that resolves to the new session details.\n     * @throws {MYJDConnectionException|MYJDApiException}\n     */\n    async reconnect() {\n        if (this._connectionType === \"remoteapi\") return true;\n\n        const response = await this.requestApi(\"/my/reconnect\", \"GET\", [\n            [\"sessiontoken\", this._sessionToken],\n            [\"regaintoken\", this._regainToken]\n        ]);\n        \n        this.updateRequestId();\n        this._sessionToken = response[\"sessiontoken\"];\n        this._regainToken = response[\"regaintoken\"];\n        await this._updateEncryptionTokens();\n        return response;\n    }\n\n    /**\n     * Disconnects from the MyJDownloader API, invalidating the current session.\n     * @returns {Promise<Object | boolean>} A promise that resolves to the API response object or true if using direct connection.\n     */\n    async disconnect() {\n        let response;\n        if (this._connectionType === \"remoteapi\") {\n            response = true;\n        } else {\n            response = await this.requestApi(\"/my/disconnect\", \"GET\", [\n                [\"sessiontoken\", this._sessionToken]\n            ]);\n        }\n        \n        // Clear all session-specific state\n        this.updateRequestId();\n        this._loginSecret = null;\n        this._deviceSecret = null;\n        this._sessionToken = null;\n        this._regainToken = null;\n        this._serverEncryptionToken = null;\n        this._deviceEncryptionToken = null;\n        this._devices = null;\n        this._connected = false;\n        return response;\n    }\n\n    /**\n     * Fetches the current list of JDownloader devices connected to the account.\n     * @returns {Promise<void>}\n     * @throws {MYJDConnectionException|MYJDApiException}\n     */\n    async updateDevices() {\n        if (this._connectionType === \"remoteapi\") return;\n        const response = await this.requestApi(\"/my/listdevices\", \"GET\", [\n            [\"sessiontoken\", this._sessionToken]\n        ]);\n        this.updateRequestId();\n        this._devices = response[\"list\"];\n    }\n\n    /**\n     * Returns the cached list of connected JDownloader devices.\n     * @returns {Object[] | null} An array of device objects (name, id, type) or null if not fetched.\n     */\n    listDevices() {\n        return this._devices;\n    }\n\n    /**\n     * Retrieves a JDDevice instance, either by name, ID, or the first available device.\n     * @param {string} [deviceName=null] - The name of the device to retrieve.\n     * @param {string} [deviceId=null] - The ID of the device to retrieve.\n     * @returns {JDDevice} An instance of the JDDevice class for the specified device.\n     * @throws {MYJDConnectionException} If not connected.\n     * @throws {MYJDDeviceNotFoundException} If the specified device is not found.\n     */\n    getDevice(deviceName = null, deviceId = null) {\n        if (!this.isConnected()) {\n            throw new MYJDConnectionException(\"No connection established\\n\");\n        }\n        if (deviceId !== null) {\n            for (const device of this._devices) {\n                if (device[\"id\"] === deviceId) return new JDDevice(this, device);\n            }\n        } else if (deviceName !== null) {\n            for (const device of this._devices) {\n                if (device[\"name\"] === deviceName) return new JDDevice(this, device);\n            }\n        } else if (this._devices.length > 0) {\n            // Return the first device if no identifier is provided\n            return new JDDevice(this, this._devices[0]);\n        }\n        throw new MYJDDeviceNotFoundException(\"Device not found\\n\");\n    }\n\n    /**\n     * Executes a raw API request, handling the cryptographic signing, encryption, and decryption required by MyJDownloader.\n     * @param {string} path - The API endpoint path (e.g., '/my/connect', '/downloadsV2/queryLinks').\n     * @param {string} [httpMethod='GET'] - 'GET' for core MyJD calls, 'POST' for device-specific actions.\n     * @param {any[] | null} [params=null] - URL parameters for GET, or request parameters for POST.\n     * @param {string | null} [action=null] - The action URL fragment for device-specific POST calls (e.g., '/t_<token>_<id>').\n     * @param {string | null} [api=null] - Overrides the base API URL (used for direct connections).\n     * @returns {Promise<Object | null>} A promise that resolves to the decrypted and parsed JSON response object.\n     * @throws {MYJDConnectionException} On network failure or if not connected.\n     * @throws {MYJDDecodeException} If the response cannot be decrypted or parsed.\n     * @throws {MYJDApiException} For API-specific errors (e.g., Auth Failed, Bad Parameters).\n     */\n    async requestApi(path, httpMethod = \"GET\", params = null, action = null, api = null) {\n        if (!api) api = this._apiUrl;\n        let data = null;\n\n        if (!this.isConnected() && path !== \"/my/connect\") {\n            throw new MYJDConnectionException(\"No connection established\\n\");\n        }\n\n        let encryptedResponse;\n        let finalUrl;\n\n        if (httpMethod === \"GET\") {\n            let query = path + \"?\";\n            if (params !== null) {\n                for (const param of params) {\n                    // Special handling for encryptedLoginSecret which is already URL encoded\n                    if (param[0] !== \"encryptedLoginSecret\") {\n                        query += `${param[0]}=${encodeURIComponent(param[1])}&`;\n                    } else {\n                        query += `&${param[0]}=${param[1]}&`;\n                    }\n                }\n            }\n            query += \"rid=\" + this._requestId;\n\n            // Cloud API calls require cryptographic signature\n            if (this._connectionType === \"myjd\") {\n                let qList = [path + \"?\"];\n                if (params) {\n                    for(const p of params) {\n                        if (p[0] !== \"encryptedLoginSecret\") qList.push(`${p[0]}=${encodeURIComponent(p[1])}`);\n                        else qList.push(`&${p[0]}=${p[1]}`);\n                    }\n                }\n                qList.push(\"rid=\" + this._requestId);\n\n                let sigData = qList[0] + qList.slice(1).join('&');\n                let signature;\n\n                // Sign using loginSecret initially, then serverEncryptionToken\n                if (this._serverEncryptionToken === null) {\n                    signature = await this._signatureCreate(this._loginSecret, sigData);\n                } else {\n                    signature = await this._signatureCreate(this._serverEncryptionToken, sigData);\n                }\n                \n                query = sigData + \"&signature=\" + signature;\n            } else {\n                 // Direct API calls (remoteapi) do not require signatures on GETs\n                 let qList = [path + \"?\"];\n                 if (params) {\n                    for(const p of params) {\n                         if (p[0] !== \"encryptedLoginSecret\") qList.push(`${p[0]}=${encodeURIComponent(p[1])}`);\n                         else qList.push(`&${p[0]}=${p[1]}`);\n                    }\n                 }\n                 qList.push(\"rid=\" + this._requestId);\n                 query = qList[0] + qList.slice(1).join('&');\n            }\n\n            finalUrl = api + query;\n            \n            try {\n                // Fetch with timeout\n                const res = await fetch(finalUrl, { method: 'GET', signal: AbortSignal.timeout(this._timeout) });\n                encryptedResponse = {\n                    status: res.status,\n                    text: await res.text()\n                };\n            } catch (e) {\n                return null; \n            }\n\n        } else {\n            // POST - Used for device actions (encrypted payload)\n            const paramsRequest = {\n                \"apiVer\": this._apiVersion,\n                \"url\": path,\n                \"params\": this._adaptParamsForRequest(params),\n                \"rid\": this._requestId\n            };\n            \n            data = JSON.stringify(paramsRequest);\n            // Fixes API quirk where 'null' is serialized as '\"null\"' when part of the parameters array\n            data = data.replace(/\"null\"/g, \"null\"); \n\n            // Encrypt the payload using the device encryption token\n            const encryptedData = await this._encrypt(this._deviceEncryptionToken, data);\n\n            let requestUrl;\n            if (action !== null) {\n                // Cloud path for device action: <api url><action><path>\n                requestUrl = api + action + path;\n            } else {\n                // Fallback (shouldn't happen for POST but kept for structure)\n                requestUrl = api + path;\n            }\n\n            try {\n                // Fetch with timeout and encrypted body\n                const res = await fetch(requestUrl, {\n                    method: 'POST',\n                    headers: { \"Content-Type\": this._contentType },\n                    body: encryptedData,\n                    signal: AbortSignal.timeout(this._timeout)\n                });\n                encryptedResponse = {\n                    status: res.status,\n                    text: await res.text()\n                };\n            } catch (e) {\n                return null;\n            }\n        }\n\n        // --- Response Handling ---\n        if (encryptedResponse.status !== 200) {\n            // Error response - attempt to parse it (may be encrypted or plain JSON error)\n            let errorMsg;\n            try {\n                errorMsg = JSON.parse(encryptedResponse.text);\n            } catch (e) {\n                try {\n                     // Try decrypting with device token if plain JSON fails (for device errors)\n                     const decrypted = await this._decrypt(this._deviceEncryptionToken, encryptedResponse.text);\n                     errorMsg = JSON.parse(decrypted);\n                } catch (e2) {\n                    // If all decoding attempts fail, throw decode exception\n                    throw new MYJDDecodeException(`Failed to decode response: ${encryptedResponse.text}`);\n                }\n            }\n            \n            // Construct detailed error message and throw specific exception\n            let msg = `\\n\\tSOURCE: ${errorMsg[\"src\"]}\\n\\tTYPE: ${errorMsg[\"type\"]}\\n------\\nREQUEST_URL: ${api}${path}`;\n            if (httpMethod === \"GET\") msg += \"\"; \n            msg += \"\\n\";\n            if (data !== null) msg += \"DATA:\\n\" + data;\n            \n            throw MYJDApiException.getException(errorMsg[\"src\"], errorMsg[\"type\"], msg);\n        }\n\n        // Decrypt the successful response\n        let response;\n        if (action === null) {\n            // General cloud response (GET)\n            if (!this._serverEncryptionToken) {\n                response = await this._decrypt(this._loginSecret, encryptedResponse.text);\n            } else {\n                response = await this._decrypt(this._serverEncryptionToken, encryptedResponse.text);\n            }\n        } else {\n            // Device action response (POST)\n            response = await this._decrypt(this._deviceEncryptionToken, encryptedResponse.text);\n        }\n\n        // Parse JSON response\n        let jsondata;\n        try {\n            jsondata = JSON.parse(response);\n        } catch(e) {\n             // Handle case where response might not be a JSON object (e.g. ping)\n             jsondata = response; \n        }\n\n        // Request ID validation\n        if (jsondata && typeof jsondata === 'object' && 'rid' in jsondata) {\n            if (jsondata['rid'] !== this._requestId) {\n                this.updateRequestId();\n                return null;\n            }\n        }\n        this.updateRequestId();\n        return jsondata;\n    }\n\n    /**\n     * Gets the current connection type being used ('myjd' for cloud, 'remoteapi' for direct).\n     * @returns {('myjd' | 'remoteapi')} The connection type.\n     */\n    getConnectionType() {\n        return this._connectionType;\n    }\n\n    /**\n     * Internal utility method to prepare parameters for transmission in a POST request.\n     * This handles converting complex objects (dicts/arrays) to JSON strings as required by the API.\n     * @private\n     * @param {any[] | null} params - The raw list of parameters.\n     * @returns {any[] | null} The adapted list of parameters ready for the API request object.\n     */\n    _adaptParamsForRequest(params) {\n        if (params === null) return null;\n        let paramsRequest = [];\n        for (const param of params) {\n            if (typeof param === 'string') {\n                paramsRequest.push(param);\n            } else if (Array.isArray(param)) {\n                // Recursively adapt nested arrays\n                paramsRequest.push(this._adaptParamsForRequest(param));\n            } else if (typeof param === 'object' && param !== null && this._connectionType === \"remoteapi\") {\n                // Direct API can handle raw objects\n                paramsRequest.push(param);\n            } else if (typeof param === 'object' && param !== null) {\n                // Cloud API requires objects to be serialized to JSON strings\n                paramsRequest.push(JSON.stringify(param));\n            } else if (typeof param === 'boolean' || typeof param === 'number') {\n                 // Booleans and numbers are also serialized to JSON strings\n                 paramsRequest.push(JSON.stringify(param));\n            } else {\n                // Fallback for other types\n                paramsRequest.push(String(param));\n            }\n        }\n        return paramsRequest;\n    }\n}\n\n// Expose class globally for non-module environments (browser)\nif (typeof window !== 'undefined') window.MyJDApi = MyJDApi;"],
  "mappings": "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",
  "names": ["EXCEPTION_API_COMMAND_NOT_FOUND", "EXCEPTION_API_INTERFACE_NOT_FOUND", "EXCEPTION_AUTH_FAILED", "EXCEPTION_BAD_PARAMETERS", "EXCEPTION_BAD_REQUEST", "EXCEPTION_CHALLENGE_FAILED", "EXCEPTION_EMAIL_FORBIDDEN", "EXCEPTION_EMAIL_INVALID", "EXCEPTION_ERROR_EMAIL_NOT_CONFIRMED", "EXCEPTION_FAILED", "EXCEPTION_FILE_NOT_FOUND", "EXCEPTION_INTERNAL_SERVER_ERROR", "EXCEPTION_MAINTENANCE", "EXCEPTION_METHOD_FORBIDDEN", "EXCEPTION_OFFLINE", "EXCEPTION_OUTDATED", "EXCEPTION_OVERLOAD", "EXCEPTION_SESSION", "EXCEPTION_STORAGE_ALREADY_EXISTS", "EXCEPTION_STORAGE_INVALID_KEY", "EXCEPTION_STORAGE_INVALID_STORAGEID", "EXCEPTION_STORAGE_KEY_NOT_FOUND", "EXCEPTION_STORAGE_LIMIT_REACHED", "EXCEPTION_STORAGE_NOT_FOUND", "EXCEPTION_TOKEN_INVALID", "EXCEPTION_TOO_MANY_REQUESTS", "EXCEPTION_UNKNOWN", "MYJDException", "message", "MYJDConnectionException", "MYJDDeviceNotFoundException", "MYJDDecodeException", "MYJDApiException", "exceptionSource", "args", "exceptionType", "EXCEPTION_UNKNOWN", "ExceptionClass", "EXCEPTION_CLASSES", "MYJDUnknownException", "MYJDApiCommandNotFoundException", "MYJDApiInterfaceNotFoundException", "MYJDAuthFailedException", "MYJDBadParametersException", "MYJDBadRequestException", "MYJDChallengeFailedException", "MYJDEmailForbiddenException", "MYJDEmailInvalidException", "MYJDErrorEmailNotConfirmedException", "MYJDFailedException", "MYJDFileNotFoundException", "MYJDInternalServerErrorException", "MYJDMaintenanceException", "MYJDMethodForbiddenException", "MYJDOfflineException", "MYJDOutdatedException", "MYJDOverloadException", "MYJDSessionException", "MYJDStorageAlreadyExistsException", "MYJDStorageInvalidKeyException", "MYJDStorageInvalidStorageIdException", "MYJDStorageKeyNotFoundException", "MYJDStorageLimitReachedException", "MYJDStorageNotFoundException", "MYJDTokenInvalidException", "MYJDTooManyRequestsException", "EXCEPTION_API_COMMAND_NOT_FOUND", "EXCEPTION_API_INTERFACE_NOT_FOUND", "EXCEPTION_AUTH_FAILED", "EXCEPTION_BAD_PARAMETERS", "EXCEPTION_BAD_REQUEST", "EXCEPTION_CHALLENGE_FAILED", "EXCEPTION_EMAIL_FORBIDDEN", "EXCEPTION_EMAIL_INVALID", "EXCEPTION_ERROR_EMAIL_NOT_CONFIRMED", "EXCEPTION_FAILED", "EXCEPTION_FILE_NOT_FOUND", "EXCEPTION_INTERNAL_SERVER_ERROR", "EXCEPTION_MAINTENANCE", "EXCEPTION_METHOD_FORBIDDEN", "EXCEPTION_OFFLINE", "EXCEPTION_OUTDATED", "EXCEPTION_OVERLOAD", "EXCEPTION_SESSION", "EXCEPTION_STORAGE_ALREADY_EXISTS", "EXCEPTION_STORAGE_INVALID_KEY", "EXCEPTION_STORAGE_INVALID_STORAGEID", "EXCEPTION_STORAGE_KEY_NOT_FOUND", "EXCEPTION_STORAGE_LIMIT_REACHED", "EXCEPTION_STORAGE_NOT_FOUND", "EXCEPTION_TOKEN_INVALID", "EXCEPTION_TOO_MANY_REQUESTS", "ENC", "DEC", "bufferToHex", "buffer", "x", "hexToBuffer", "hex", "bytes", "i", "base64ToBuffer", "base64", "binString", "bufferToBase64", "binary", "len", "concatBuffers", "buffers", "totalLen", "acc", "b", "tmp", "offset", "u8", "Accounts", "device", "premiumHoster", "username", "password", "params", "type", "hostmask", "accountIds", "hoster", "query", "accountId", "basicAuth", "System", "force", "JD", "Update", "Config", "interfaceName", "storage", "key", "value", "DownloadController", "linkIds", "packageIds", "Extension", "id", "enabled", "Dialog", "data", "icon", "properties", "dialogType", "Linkgrabber", "action", "mode", "selectionType", "type_", "content", "urlDisplayType", "priority", "enable", "packageId", "newName", "linkId", "newPkgName", "downloadPath", "Downloads", "directory", "Captcha", "captchaId", "solution", "Reconnect", "Toolbar", "JDDevice", "jd", "deviceDict", "response", "directInfo", "conn", "d", "path", "httpAction", "actionUrl", "now", "MYJDConnectionException", "connection", "api", "MyJDApi", "appKey", "email", "domain", "oldToken", "sessionTokenBuffer", "input", "keyBuffer", "signature", "secretTokenBuffer", "dataBase64", "secretToken", "half", "initVector", "keyRaw", "encryptedData", "decryptedBuffer", "dataStr", "encodedData", "encryptedBuffer", "ip", "port", "timeout", "deviceName", "deviceId", "MYJDDeviceNotFoundException", "httpMethod", "encryptedResponse", "finalUrl", "param", "qList", "p", "sigData", "res", "paramsRequest", "requestUrl", "errorMsg", "decrypted", "MYJDDecodeException", "msg", "MYJDApiException", "jsondata"]
}
